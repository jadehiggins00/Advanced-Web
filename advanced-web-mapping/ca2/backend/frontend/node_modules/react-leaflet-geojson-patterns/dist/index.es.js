import { Path, withLeaflet } from 'react-leaflet';
import { GeoJSON } from 'leaflet';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    nullTag = '[object Null]',
    proxyTag = '[object Proxy]',
    undefinedTag = '[object Undefined]';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var Symbol$1 = root.Symbol,
    symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var lodash_isfunction = isFunction;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * GeoJSON supported fillPattern style
 */

var GeoJSONFillable = function (_Path) {
  inherits(GeoJSONFillable, _Path);

  function GeoJSONFillable() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, GeoJSONFillable);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = GeoJSONFillable.__proto__ || Object.getPrototypeOf(GeoJSONFillable)).call.apply(_ref, [this].concat(args))), _this), _this.addedNotExistedPatterns = function (layers, style) {
      var map = _this.props.leaflet.map;

      if (!style) return;
      if (lodash_isfunction(style)) layers.forEach(function (layer) {
        var featureStyle = style(layer.feature);
        if (featureStyle.fillPattern && !map.hasPattern(featureStyle.fillPattern)) {
          map.once('patternadd', function (_ref2) {
            var pattern = _ref2.pattern;

            // console.log('added', pattern, layer);
            setTimeout(function () {
              return layer.setStyle({ fillPattern: pattern });
            }, 0);
          });
          map.addPattern(featureStyle.fillPattern);
        }
      });else if (style.fillPattern) {
        _this.addPatternToLayer(style.fillPattern, _this);
      }
    }, _this.addPatternToLayer = function (pattern, layer) {
      var map = _this.props.leaflet.map;

      if (!map.hasPattern(pattern)) {
        map.once('patternadd', function (_ref3) {
          var pattern = _ref3.pattern;

          setTimeout(function () {
            return layer.setStyle({ fillPattern: pattern });
          }, 0);
        });
        map.addPattern(pattern);
      } else {
        layer.setStyle({ fillPattern: pattern });
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(GeoJSONFillable, [{
    key: 'createLeafletElement',
    value: function createLeafletElement(props) {
      var _this2 = this;

      var el = new GeoJSON(props.data, this.getOptions(props));
      el.once('add', function (e) {
        _this2.addedNotExistedPatterns(e.target.getLayers(), props.style);
      });
      return el;
    }
  }, {
    key: 'updateLeafletElement',
    value: function updateLeafletElement(fromProps, toProps) {
      if (lodash_isfunction(toProps.style)) {
        this.addedNotExistedPatterns(this.leafletElement.getLayers(), toProps.style);
        this.setStyle(toProps.style);
      } else {
        if (fromProps.style.fillPattern !== toProps.style.fillPattern) {
          this.addPatternToLayer(toProps.style.fillPattern, this);
        }
        this.setStyleIfChanged(fromProps, toProps);
      }
    }
  }]);
  return GeoJSONFillable;
}(Path);
/** @component */


var GeoJSONFillable$1 = withLeaflet(GeoJSONFillable);

/*
 Leaflet.pattern, Provides tools to set the backgrounds of vector shapes in Leaflet to be patterns.
 https://github.com/teastman/Leaflet.pattern
 (c) 2015, Tyler Eastman
*/
var getId = function getId(value) {
  var id = value.options.key || L.stamp(value);
  return id;
};
var L = window.L;

(function (window, document, undefined) {
  /*
  * L.Pattern is the base class for fill patterns for leaflet Paths.
  */

  L.Pattern = L.Class.extend({
    includes: L.Evented.prototype || L.Mixin.Events,

    options: {
      x: 0,
      y: 0,
      width: 8,
      height: 8,
      patternUnits: 'userSpaceOnUse',
      patternContentUnits: 'userSpaceOnUse',
      key: ''
      // angle: <0 - 360>
      // patternTransform: <transform-list>
    },

    _addShapes: L.Util.falseFn,
    _update: L.Util.falseFn,

    initialize: function initialize(options) {
      this._shapes = {};
      if (!options.key) throw Error('Should define a unique option key');
      L.setOptions(this, options);
    },

    onAdd: function onAdd(map) {
      this._map = map.target ? map.target : map;
      if (!this._map._initDefRoot) {
        debugger;
      }
      this._map._initDefRoot();

      // Create the DOM Object for the pattern.
      this._initDom();

      // Any shapes that were added before this was added to the map need to have their onAdd called.
      for (var i in this._shapes) {
        this._shapes[i].onAdd(this);
      }

      // Call any children that want to add their own shapes.
      this._addShapes();

      // Add the DOM Object to the DOM Tree
      this._addDom();
      this.redraw();

      if (this.getEvents) {
        this._map.on(this.getEvents(), this);
      }
      this.fire('add');
      this._map.fire('patternadd', { pattern: this });
    },

    onRemove: function onRemove() {
      this._removeDom();
    },

    redraw: function redraw() {
      if (this._map) {
        this._update();
        for (var i in this._shapes) {
          this._shapes[i].redraw();
        }
      }
      return this;
    },

    setStyle: function setStyle(style) {
      L.setOptions(this, style);
      if (this._map) {
        this._updateStyle();
        this.redraw();
      }
      return this;
    },

    addTo: function addTo(map) {
      map.addPattern(this);
      return this;
    },

    remove: function remove() {
      return this.removeFrom(this._map);
    },

    removeFrom: function removeFrom(map) {
      if (map) {
        map.removePattern(this);
      }
      return this;
    }
  });

  L.Map.addInitHook(function () {
    this._patterns = {};
  });

  L.Map.include({
    addPattern: function addPattern(pattern) {
      var id = getId(pattern);
      if (this._patterns[id]) {
        return pattern;
      }
      this._patterns[id] = pattern;

      this.whenReady(pattern.onAdd, pattern);
      return this;
    },

    removePattern: function removePattern(pattern) {
      var id = getId(pattern);
      if (!this._patterns[id]) {
        return this;
      }

      if (this._loaded) {
        pattern.onRemove(this);
      }

      if (pattern.getEvents) {
        this.off(pattern.getEvents(), pattern);
      }

      delete this._patterns[id];

      if (this._loaded) {
        this.fire('patternremove', { pattern: pattern });
        pattern.fire('remove');
      }

      pattern._map = null;
      return this;
    },

    hasPattern: function hasPattern(pattern) {
      return !!pattern && getId(pattern) in this._patterns;
    }
  });

  L.Pattern.SVG_NS = 'http://www.w3.org/2000/svg';

  L.Pattern = L.Pattern.extend({
    _createElement: function _createElement(name) {
      return document.createElementNS(L.Pattern.SVG_NS, name);
    },

    _initDom: function _initDom() {
      this._dom = this._createElement('pattern');
      if (this.options.className) {
        L.DomUtil.addClass(this._dom, this.options.className);
      }
      this._updateStyle();
    },

    _addDom: function _addDom() {
      this._map._defRoot.appendChild(this._dom);
    },

    _removeDom: function _removeDom() {
      L.DomUtil.remove(this._dom);
    },

    _updateStyle: function _updateStyle() {
      var dom = this._dom;

      var options = this.options;

      if (!dom) {
        return;
      }

      dom.setAttribute('id', getId(this));
      dom.setAttribute('x', options.x);
      dom.setAttribute('y', options.y);
      dom.setAttribute('width', options.width);
      dom.setAttribute('height', options.height);
      dom.setAttribute('patternUnits', options.patternUnits);
      dom.setAttribute('patternContentUnits', options.patternContentUnits);

      if (options.patternTransform || options.angle) {
        var transform = options.patternTransform ? options.patternTransform + ' ' : '';
        transform += options.angle ? 'rotate(' + options.angle + ') ' : '';
        dom.setAttribute('patternTransform', transform);
      } else {
        dom.removeAttribute('patternTransform');
      }

      for (var i in this._shapes) {
        this._shapes[i]._updateStyle();
      }
    }
  });

  L.Map.include({
    _initDefRoot: function _initDefRoot() {
      if (!this._defRoot) {
        if (typeof this.getRenderer === 'function') {
          var renderer = this.getRenderer(this);
          this._defRoot = L.Pattern.prototype._createElement('defs');
          renderer._container.appendChild(this._defRoot);
        } else {
          if (!this._pathRoot) {
            this._initPathRoot();
          }
          this._defRoot = L.Pattern.prototype._createElement('defs');
          this._pathRoot.appendChild(this._defRoot);
        }
      }
    }
  });

  if (L.SVG) {
    L.SVG.include({
      _superUpdateStyle: L.SVG.prototype._updateStyle,

      _updateStyle: function _updateStyle(layer) {
        this._superUpdateStyle(layer);

        if (layer.options.fill && layer.options.fillPattern) {
          layer._path.setAttribute('fill', 'url(#' + getId(layer.options.fillPattern) + ')');
        }
      }
    });
  } else {
    L.Path.include({
      _superUpdateStyle: L.Path.prototype._updateStyle,

      _updateStyle: function _updateStyle() {
        this._superUpdateStyle();

        if (this.options.fill && this.options.fillPattern) {
          this._path.setAttribute('fill', 'url(#' + getId(this.options.fillPattern) + ')');
        }
      }
    });
  }

  /*
     * L.StripePattern is an implementation of Pattern that creates stripes.
     */

  L.StripePattern = L.Pattern.extend({
    options: {
      weight: 4,
      spaceWeight: 4,
      color: '#000000',
      spaceColor: '#ffffff',
      opacity: 1.0,
      spaceOpacity: 0.0
    },

    _addShapes: function _addShapes() {
      this._stripe = new L.PatternPath({
        stroke: true,
        weight: this.options.weight,
        color: this.options.color,
        opacity: this.options.opacity
      });

      this._space = new L.PatternPath({
        stroke: true,
        weight: this.options.spaceWeight,
        color: this.options.spaceColor,
        opacity: this.options.spaceOpacity
      });

      this.addShape(this._stripe);
      this.addShape(this._space);

      this._update();
    },

    _update: function _update() {
      this._stripe.options.d = 'M0 ' + this._stripe.options.weight / 2 + ' H ' + this.options.width;
      this._space.options.d = 'M0 ' + (this._stripe.options.weight + this._space.options.weight / 2) + ' H ' + this.options.width;
    },

    setStyle: L.Pattern.prototype.setStyle
  });

  L.stripePattern = function (options) {
    return new L.StripePattern(options);
  };

  /*
     * L.PatternShape is the base class that is used to define the shapes in Patterns.
     */

  L.PatternShape = L.Class.extend({
    options: {
      stroke: true,
      color: '#3388ff',
      weight: 3,
      opacity: 1,
      lineCap: 'round',
      lineJoin: 'round',
      // dashArray: null
      // dashOffset: null

      // fill: false
      // fillColor: same as color by default
      fillOpacity: 0.2,
      fillRule: 'evenodd'
      // fillPattern: L.Pattern
    },

    initialize: function initialize(options) {
      L.setOptions(this, options);
    },

    // Called when the parent Pattern get's added to the map,
    // or when added to a Pattern that is already on the map.
    onAdd: function onAdd(pattern) {
      this._pattern = pattern;
      if (this._pattern._dom) {
        this._initDom(); // This function is implemented by it's children.
        this._addDom();
      }
    },

    addTo: function addTo(pattern) {
      pattern.addShape(this);
      return this;
    },

    redraw: function redraw() {
      if (this._pattern) {
        this._updateShape(); // This function is implemented by it's children.
      }
      return this;
    },

    setStyle: function setStyle(style) {
      L.setOptions(this, style);
      if (this._pattern) {
        this._updateStyle();
      }
      return this;
    },

    setShape: function setShape(shape) {
      this.options = L.extend({}, this.options, shape);
      this._updateShape();
    }
  });

  L.Pattern.include({
    addShape: function addShape(shape) {
      var id = getId(shape);
      if (this._shapes[id]) {
        return shape;
      }
      this._shapes[id] = shape;
      shape.onAdd(this);
    }
  });

  L.PatternShape.SVG_NS = 'http://www.w3.org/2000/svg';

  L.PatternShape = L.PatternShape.extend({
    _createElement: function _createElement(name) {
      return document.createElementNS(L.PatternShape.SVG_NS, name);
    },

    _initDom: L.Util.falseFn,
    _updateShape: L.Util.falseFn,

    _initDomElement: function _initDomElement(type) {
      this._dom = this._createElement(type);
      if (this.options.className) {
        L.DomUtil.addClass(this._dom, this.options.className);
      }
      this._updateStyle();
    },

    _addDom: function _addDom() {
      this._pattern._dom.appendChild(this._dom);
    },

    _updateStyle: function _updateStyle() {
      var dom = this._dom;

      var options = this.options;

      if (!dom) {
        return;
      }

      if (options.stroke) {
        dom.setAttribute('stroke', options.color);
        dom.setAttribute('stroke-opacity', options.opacity);
        dom.setAttribute('stroke-width', options.weight);
        dom.setAttribute('stroke-linecap', options.lineCap);
        dom.setAttribute('stroke-linejoin', options.lineJoin);

        if (options.dashArray) {
          dom.setAttribute('stroke-dasharray', options.dashArray);
        } else {
          dom.removeAttribute('stroke-dasharray');
        }

        if (options.dashOffset) {
          dom.setAttribute('stroke-dashoffset', options.dashOffset);
        } else {
          dom.removeAttribute('stroke-dashoffset');
        }
      } else {
        dom.setAttribute('stroke', 'none');
      }

      if (options.fill) {
        if (options.fillPattern) {
          dom.setAttribute('fill', 'url(#' + getId(options.fillPattern) + ')');
        } else {
          dom.setAttribute('fill', options.fillColor || options.color);
        }
        dom.setAttribute('fill-opacity', options.fillOpacity);
        dom.setAttribute('fill-rule', options.fillRule || 'evenodd');
      } else {
        dom.setAttribute('fill', 'none');
      }

      dom.setAttribute('pointer-events', options.pointerEvents || (options.interactive ? 'visiblePainted' : 'none'));
    }
  });

  /*
     * L.PatternPath is the implementation of PatternShape for adding Paths
     */

  L.PatternPath = L.PatternShape.extend({
    //	options: {
    // d: <svg path code>
    //	},

    _initDom: function _initDom() {
      this._initDomElement('path');
    },

    _updateShape: function _updateShape() {
      if (!this._dom) {
        return;
      }
      this._dom.setAttribute('d', this.options.d);
    }
  });

  /*
     * L.PatternCircle is the implementation of PatternShape for adding Circles
     */

  L.PatternCircle = L.PatternShape.extend({
    options: {
      x: 0,
      y: 0,
      radius: 0
    },

    _initDom: function _initDom() {
      this._initDomElement('circle');
    },

    _updateShape: function _updateShape() {
      if (!this._dom) {
        return;
      }
      this._dom.setAttribute('cx', this.options.x);
      this._dom.setAttribute('cy', this.options.y);
      this._dom.setAttribute('r', this.options.radius);
    }
  });

  /*
     * L.PatternRect is the implementation of PatternShape for adding Rectangles
     */

  L.PatternRect = L.PatternShape.extend({
    options: {
      x: 0,
      y: 0,
      width: 10,
      height: 10
      // rx: x radius for rounded corners
      // ry: y radius for rounded corners
    },

    _initDom: function _initDom() {
      this._initDomElement('rect');
    },

    _updateShape: function _updateShape() {
      if (!this._dom) {
        return;
      }
      this._dom.setAttribute('x', this.options.x);
      this._dom.setAttribute('y', this.options.y);
      this._dom.setAttribute('width', this.options.width);
      this._dom.setAttribute('height', this.options.height);
      if (this.options.rx) {
        this._dom.setAttribute('rx', this.options.rx);
      }
      if (this.options.ry) {
        this._dom.setAttribute('ry', this.options.ry);
      }
    }
  });

  L.CheckerBoardPattern = L.Pattern.extend({
    options: {
      color: '#000000',
      fillOpacity: 1
    },

    _addShapes: function _addShapes() {
      this._shape1 = new L.PatternRect({
        stroke: false,
        fillOpacity: this.options.fillOpacity,
        color: this.options.color,
        fill: this.options.color,
        x: 0,
        y: 0,
        width: this.options.width / 2,
        height: this.options.height / 2
      });

      this._shape2 = new L.PatternRect({
        stroke: false,
        fillOpacity: this.options.fillOpacity,
        color: this.options.color,
        fill: this.options.color,
        x: this.options.width / 2,
        y: this.options.height / 2,
        width: this.options.width / 2,
        height: this.options.height / 2
      });

      this.addShape(this._shape1);
      this.addShape(this._shape2);

      this._update();
    },

    _update: function _update() {},

    setStyle: L.Pattern.prototype.setStyle
  });
})(window, document);

var L$1 = window.L;

/**
 * **key**: {string} - required.<br/>
 * **weight**: {number} (default: 4) - The width of the primary stripe.<br/>
 * **spaceWeight**: {number} (default: 4) - The width of the secondaty stripe, typically an empty space.<br/>
 * **color**: {color} (default: #000000) - The color of the primary stripe.<br/>
 * **spaceColor**: {color} (default: #ffffff) - The color of the secondary stripe.<br/>
 * **opacity**: {0.0 - 1.0} (default: 1.0) - The opacity of the primary stripe.<br/>
 * **spaceOpacity**: {0.0 - 1.0} (default: 0.0) - The opacity of the secondary stripe.<br/>
 *
 * @see See [API](https://github.com/teastman/Leaflet.pattern#stripes) for a list of properties
 * @component
 */
var StripePattern = function StripePattern(options) {
  return new L$1.StripePattern(options);
};

var L$2 = window.L;
var BasePattern = function BasePattern(options, Shape) {
  var shape = new Shape(options);
  var pattern = new L$2.Pattern(options);
  pattern.addShape(shape);
  return pattern;
};

var L$3 = window.L;

/**
 * **key**: {string} - required.<br/>
 * **x**: {number} (default: 0) - x offset of the circle.<br/>
 * **y**: {number} (default: 0) - y offset of the circle.<br/>
 * **radius**: {number} (default: 0) - radius of the circle.<br/>

 * @see See [API](https://github.com/teastman/Leaflet.pattern#circle) for a list of properties
 * @component
 */
var CirclePattern = function CirclePattern(options) {
  return BasePattern(options, L$3.PatternCircle);
};

var L$4 = window.L;

/**
 * **key**: {string} - required.<br/>
 * **x**: {number} (default: 0) - x offset of the rectangle.<br/>
 * **y**: {number} (default: 0) - y offset of the rectangle.<br/>
 * **width**: {number} (default: 10) - width of the rectangle.<br/>
 * **height**: {number} (default: 10) - height of the rectangle.<br/>
 * **rx**: {number} (default: null) - x radius for rounded corners.<br/>
 * **ry**: {number} (default: null) - y radius for rounded corners.<br/>

 * @see See [API](https://github.com/teastman/Leaflet.pattern#rectangle) for a list of properties
 * @component
 */
var RectPattern = function RectPattern(options) {
  return BasePattern(options, L$4.PatternRect);
};

var L$5 = window.L;

/**
 * **key** {string} - required.<br/>
 * **d** {path} (default: null) - The SVG path definition.
 * @see See [API](https://github.com/teastman/Leaflet.pattern#path) for a list of properties
 * @component
 */
var PathPattern = function PathPattern(options) {
  return BasePattern(options, L$5.PatternPath);
};

var L$6 = window.L;

/**
 * **key**: {string} - required.<br/>
 * **width**: {number} (default: 12) - The width of the square.<br/>
 * **height**: {number} (default: 12) - The height of the square.<br/>
 * **color**: {color} (default: #000000) - The color of the square.<br/>
 * **fillOpacity**: {number} (default: 1) - The opacity of the primary square.<br/>

 * @component
 */
var CheckerBoardPattern = function CheckerBoardPattern(options) {
  return new L$6.CheckerBoardPattern(options);
};

var index = { StripePattern: StripePattern, CirclePattern: CirclePattern, RectPattern: RectPattern, PathPattern: PathPattern, CheckerBoardPattern: CheckerBoardPattern };

export { GeoJSONFillable$1 as GeoJSONFillable, index as Patterns };
//# sourceMappingURL=index.es.js.map
